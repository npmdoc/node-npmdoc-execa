<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/sindresorhus/execa#readme">execa (v0.6.3)</a>
</h1>
<h4>A better `child_process`</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.execa">module execa</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.execa">
            function <span class="apidocSignatureSpan"></span>execa
            <span class="apidocSignatureSpan">(cmd, args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.errname">
            function <span class="apidocSignatureSpan">execa.</span>errname
            <span class="apidocSignatureSpan">(uv, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.index">
            function <span class="apidocSignatureSpan">execa.</span>index
            <span class="apidocSignatureSpan">(cmd, args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.shell">
            function <span class="apidocSignatureSpan">execa.</span>shell
            <span class="apidocSignatureSpan">(cmd, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.shellSync">
            function <span class="apidocSignatureSpan">execa.</span>shellSync
            <span class="apidocSignatureSpan">(cmd, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.spawn">
            function <span class="apidocSignatureSpan">execa.</span>spawn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.stderr">
            function <span class="apidocSignatureSpan">execa.</span>stderr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.stdout">
            function <span class="apidocSignatureSpan">execa.</span>stdout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.sync">
            function <span class="apidocSignatureSpan">execa.</span>sync
            <span class="apidocSignatureSpan">(cmd, args, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.execa.errname">module execa.errname</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.errname.errname">
            function <span class="apidocSignatureSpan">execa.</span>errname
            <span class="apidocSignatureSpan">(uv, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.errname.__test__">
            function <span class="apidocSignatureSpan">execa.errname.</span>__test__
            <span class="apidocSignatureSpan">(uv, code)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.execa.index">module execa.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.index.index">
            function <span class="apidocSignatureSpan">execa.</span>index
            <span class="apidocSignatureSpan">(cmd, args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.index.shell">
            function <span class="apidocSignatureSpan">execa.index.</span>shell
            <span class="apidocSignatureSpan">(cmd, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.index.shellSync">
            function <span class="apidocSignatureSpan">execa.index.</span>shellSync
            <span class="apidocSignatureSpan">(cmd, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.index.spawn">
            function <span class="apidocSignatureSpan">execa.index.</span>spawn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.index.stderr">
            function <span class="apidocSignatureSpan">execa.index.</span>stderr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.index.stdout">
            function <span class="apidocSignatureSpan">execa.index.</span>stdout
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.execa.index.sync">
            function <span class="apidocSignatureSpan">execa.index.</span>sync
            <span class="apidocSignatureSpan">(cmd, args, opts)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.execa" id="apidoc.module.execa">module execa</a></h1>


    <h2>
        <a href="#apidoc.element.execa.execa" id="apidoc.element.execa.execa">
        function <span class="apidocSignatureSpan"></span>execa
        <span class="apidocSignatureSpan">(cmd, args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cmd, args, opts) =&gt; {
	let joinedCmd = cmd;

	if (Array.isArray(args) &amp;&amp; args.length &gt; 0) {
		joinedCmd += ' ' + args.join(' ');
	}

	const parsed = handleArgs(cmd, args, opts);
	const encoding = parsed.opts.encoding;
	const maxBuffer = parsed.opts.maxBuffer;

	let spawned;
	try {
		spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
	} catch (err) {
		return Promise.reject(err);
	}

	let removeExitHandler;
	if (parsed.opts.cleanup) {
		removeExitHandler = onExit(() =&gt; {
			spawned.kill();
		});
	}

	let timeoutId = null;
	let timedOut = false;

	const cleanupTimeout = () =&gt; {
		if (timeoutId) {
			clearTimeout(timeoutId);
			timeoutId = null;
		}
	};

	if (parsed.opts.timeout &gt; 0) {
		timeoutId = setTimeout(() =&gt; {
			timeoutId = null;
			timedOut = true;
			spawned.kill(parsed.killSignal);
		}, parsed.opts.timeout);
	}

	const processDone = new Promise(resolve =&gt; {
		spawned.on('exit', (code, signal) =&gt; {
			cleanupTimeout();
			resolve({code, signal});
		});

		spawned.on('error', err =&gt; {
			cleanupTimeout();
			resolve({err});
		});

		if (spawned.stdin) {
			spawned.stdin.on('error', err =&gt; {
				cleanupTimeout();
				resolve({err});
			});
		}
	});

	function destroy() {
		if (spawned.stdout) {
			spawned.stdout.destroy();
		}

		if (spawned.stderr) {
			spawned.stderr.destroy();
		}
	}

	const promise = pFinally(Promise.all([
		processDone,
		getStream(spawned, 'stdout', encoding, maxBuffer),
		getStream(spawned, 'stderr', encoding, maxBuffer)
	]).then(arr =&gt; {
		const result = arr[0];
		const stdout = arr[1];
		const stderr = arr[2];

		let err = result.err;
		const code = result.code;
		const signal = result.signal;

		if (removeExitHandler) {
			removeExitHandler();
		}

		if (err || code !== 0 || signal !== null) {
			if (!err) {
				const output = parsed.opts.stdio === 'inherit' ? '' : `\n${stderr}${stdout}`;
				err = new Error(`Command failed: ${joinedCmd}${output}`);
				err.code = code &lt; 0 ? errname(code) : code;
			}

			// TODO: missing some timeout logic for killed
			// https://github.com/nodejs/node/blob/master/lib/child_process.js#L203
			// err.killed = spawned.killed || killed;
			err.killed = err.killed || spawned.killed;

			err.stdout = stdout;
			err.stderr = stderr;
			err.failed = true;
			err.signal = signal || null;
			err.cmd = joinedCmd;
			err.timedOut = timedOut;

			if (!parsed.opts.reject) {
				return err;
			}

			throw err;
		}

		return {
			stdout: handleOutput(parsed.opts, stdout),
			stderr: handleOutput(parsed.opts, stderr),
			code: 0,
			failed: false,
			killed: false,
			signal: null,
			cmd: joinedCmd,
			timedOut: false
		};
	}), destroy);

	crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);

	handleInput(spawned, parsed.opts);

	spawned.then = promise.then.bind(promise);
	spawned.catch = promise.catch.bind(promise);

	return spawned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.errname" id="apidoc.element.execa.errname">
        function <span class="apidocSignatureSpan">execa.</span>errname
        <span class="apidocSignatureSpan">(uv, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">code =&gt; errname(uv, code)</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} catch (err) {
	console.error('execa/lib/errname: unable to establish process.binding(\'uv\')', err);
	uv = null;
}

function errname(uv, code) {
	if (uv) {
		return uv.<span class="apidocCodeKeywordSpan">errname</span>(code);
	}

	if (!(code &lt; 0)) {
		throw new Error('err &gt;= 0');
	}

	return `Unknown system error ${code}`;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.index" id="apidoc.element.execa.index">
        function <span class="apidocSignatureSpan">execa.</span>index
        <span class="apidocSignatureSpan">(cmd, args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cmd, args, opts) =&gt; {
	let joinedCmd = cmd;

	if (Array.isArray(args) &amp;&amp; args.length &gt; 0) {
		joinedCmd += ' ' + args.join(' ');
	}

	const parsed = handleArgs(cmd, args, opts);
	const encoding = parsed.opts.encoding;
	const maxBuffer = parsed.opts.maxBuffer;

	let spawned;
	try {
		spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
	} catch (err) {
		return Promise.reject(err);
	}

	let removeExitHandler;
	if (parsed.opts.cleanup) {
		removeExitHandler = onExit(() =&gt; {
			spawned.kill();
		});
	}

	let timeoutId = null;
	let timedOut = false;

	const cleanupTimeout = () =&gt; {
		if (timeoutId) {
			clearTimeout(timeoutId);
			timeoutId = null;
		}
	};

	if (parsed.opts.timeout &gt; 0) {
		timeoutId = setTimeout(() =&gt; {
			timeoutId = null;
			timedOut = true;
			spawned.kill(parsed.killSignal);
		}, parsed.opts.timeout);
	}

	const processDone = new Promise(resolve =&gt; {
		spawned.on('exit', (code, signal) =&gt; {
			cleanupTimeout();
			resolve({code, signal});
		});

		spawned.on('error', err =&gt; {
			cleanupTimeout();
			resolve({err});
		});

		if (spawned.stdin) {
			spawned.stdin.on('error', err =&gt; {
				cleanupTimeout();
				resolve({err});
			});
		}
	});

	function destroy() {
		if (spawned.stdout) {
			spawned.stdout.destroy();
		}

		if (spawned.stderr) {
			spawned.stderr.destroy();
		}
	}

	const promise = pFinally(Promise.all([
		processDone,
		getStream(spawned, 'stdout', encoding, maxBuffer),
		getStream(spawned, 'stderr', encoding, maxBuffer)
	]).then(arr =&gt; {
		const result = arr[0];
		const stdout = arr[1];
		const stderr = arr[2];

		let err = result.err;
		const code = result.code;
		const signal = result.signal;

		if (removeExitHandler) {
			removeExitHandler();
		}

		if (err || code !== 0 || signal !== null) {
			if (!err) {
				const output = parsed.opts.stdio === 'inherit' ? '' : `\n${stderr}${stdout}`;
				err = new Error(`Command failed: ${joinedCmd}${output}`);
				err.code = code &lt; 0 ? errname(code) : code;
			}

			// TODO: missing some timeout logic for killed
			// https://github.com/nodejs/node/blob/master/lib/child_process.js#L203
			// err.killed = spawned.killed || killed;
			err.killed = err.killed || spawned.killed;

			err.stdout = stdout;
			err.stderr = stderr;
			err.failed = true;
			err.signal = signal || null;
			err.cmd = joinedCmd;
			err.timedOut = timedOut;

			if (!parsed.opts.reject) {
				return err;
			}

			throw err;
		}

		return {
			stdout: handleOutput(parsed.opts, stdout),
			stderr: handleOutput(parsed.opts, stderr),
			code: 0,
			failed: false,
			killed: false,
			signal: null,
			cmd: joinedCmd,
			timedOut: false
		};
	}), destroy);

	crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);

	handleInput(spawned, parsed.opts);

	spawned.then = promise.then.bind(promise);
	spawned.catch = promise.catch.bind(promise);

	return spawned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.shell" id="apidoc.element.execa.shell">
        function <span class="apidocSignatureSpan">execa.</span>shell
        <span class="apidocSignatureSpan">(cmd, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cmd, opts) =&gt; handleShell(module.exports, cmd, opts)</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	console.log(result.stdout);
	//=&gt; 'unicorns'
});

// pipe the child process stdout to the current stdout
execa('echo', ['unicorns']).stdout.pipe(process.stdout);

execa.<span class="apidocCodeKeywordSpan">shell</span>('echo unicorns').then(result =&gt; {
	console.log(result.stdout);
	//=&gt; 'unicorns'
});

// example of catching an error
execa.shell('exit 3').catch(error =&gt; {
	console.log(error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.shellSync" id="apidoc.element.execa.shellSync">
        function <span class="apidocSignatureSpan">execa.</span>shellSync
        <span class="apidocSignatureSpan">(cmd, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cmd, opts) =&gt; handleShell(module.exports.sync, cmd, opts)</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Same options as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
), except the default encoding is `utf8` instead of `buffer`.

Returns the same result object as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
).

This method throws an `Error` if the command fails.

### execa.<span class="apidocCodeKeywordSpan">shellSync</span>(file, [options])

Execute a command synchronously through the system shell.

Same options as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
), except the default encoding is `utf8` instead of `buffer`.

Returns the same result object as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.spawn" id="apidoc.element.execa.spawn">
        function <span class="apidocSignatureSpan">execa.</span>spawn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated() {
  warned = exports.printDeprecationMessage(msg, warned, deprecated);
  if (new.target) {
    return Reflect.construct(fn, arguments, new.target);
  }
  return fn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	const parsed = handleArgs(cmd, args, opts);
	const encoding = parsed.opts.encoding;
	const maxBuffer = parsed.opts.maxBuffer;

	let spawned;
	try {
		spawned = childProcess.<span class="apidocCodeKeywordSpan">spawn</span>(parsed.cmd, parsed.args, parsed.opts);
	} catch (err) {
		return Promise.reject(err);
	}

	let removeExitHandler;
	if (parsed.opts.cleanup) {
		removeExitHandler = onExit(() =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.stderr" id="apidoc.element.execa.stderr">
        function <span class="apidocSignatureSpan">execa.</span>stderr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stderr = function () {
	// TODO: set `stdout: 'ignore'` when that option is implemented
	return module.exports.apply(null, arguments).then(x =&gt; x.stderr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Returns a [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess), which is enhanced
 to also be a `Promise` for a result `Object` with `stdout` and `stderr` properties.

### execa.stdout(file, [arguments], [options])

Same as `execa()`, but returns only `stdout`.

### execa.<span class="apidocCodeKeywordSpan">stderr</span>(file, [arguments], [options])

Same as `execa()`, but returns only `stderr`.

### execa.shell(command, [options])

Execute a command through the system shell. Prefer `execa()` whenever possible, as it's both faster and safer.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.stdout" id="apidoc.element.execa.stdout">
        function <span class="apidocSignatureSpan">execa.</span>stdout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stdout = function () {
	// TODO: set `stderr: 'ignore'` when that option is implemented
	return module.exports.apply(null, arguments).then(x =&gt; x.stdout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Same options as [`child_process.spawn`](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options
).

Think of this as a mix of `child_process.execFile` and `child_process.spawn`.

Returns a [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess), which is enhanced
 to also be a `Promise` for a result `Object` with `stdout` and `stderr` properties.

### execa.<span class="apidocCodeKeywordSpan">stdout</span>(file, [arguments], [options])

Same as `execa()`, but returns only `stdout`.

### execa.stderr(file, [arguments], [options])

Same as `execa()`, but returns only `stderr`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.sync" id="apidoc.element.execa.sync">
        function <span class="apidocSignatureSpan">execa.</span>sync
        <span class="apidocSignatureSpan">(cmd, args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cmd, args, opts) =&gt; {
	const parsed = handleArgs(cmd, args, opts);

	if (isStream(parsed.opts.input)) {
		throw new TypeError('The `input` option cannot be a stream in sync mode');
	}

	const result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);

	if (result.error || result.status !== 0) {
		throw (result.error || new Error(result.stderr === '' ? result.stdout : result.stderr));
	}

	result.stdout = handleOutput(parsed.opts, result.stdout);
	result.stderr = handleOutput(parsed.opts, result.stderr);

	return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Same options as [`child_process.spawn`](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options
).

Returns a [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess).

The `child_process` instance is enhanced to also be promise for a result object with `stdout` and `stderr` properties.

### execa.<span class="apidocCodeKeywordSpan">sync</span>(file, [arguments], [options])

Execute a file synchronously.

Same options as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
), except the default encoding is `utf8` instead of `buffer`.

Returns the same result object as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
).
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.execa.errname" id="apidoc.module.execa.errname">module execa.errname</a></h1>


    <h2>
        <a href="#apidoc.element.execa.errname.errname" id="apidoc.element.execa.errname.errname">
        function <span class="apidocSignatureSpan">execa.</span>errname
        <span class="apidocSignatureSpan">(uv, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">code =&gt; errname(uv, code)</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} catch (err) {
	console.error('execa/lib/errname: unable to establish process.binding(\'uv\')', err);
	uv = null;
}

function errname(uv, code) {
	if (uv) {
		return uv.<span class="apidocCodeKeywordSpan">errname</span>(code);
	}

	if (!(code &lt; 0)) {
		throw new Error('err &gt;= 0');
	}

	return `Unknown system error ${code}`;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.errname.__test__" id="apidoc.element.execa.errname.__test__">
        function <span class="apidocSignatureSpan">execa.errname.</span>__test__
        <span class="apidocSignatureSpan">(uv, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function errname(uv, code) {
	if (uv) {
		return uv.errname(code);
	}

	if (!(code &lt; 0)) {
		throw new Error('err &gt;= 0');
	}

	return `Unknown system error ${code}`;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.execa.index" id="apidoc.module.execa.index">module execa.index</a></h1>


    <h2>
        <a href="#apidoc.element.execa.index.index" id="apidoc.element.execa.index.index">
        function <span class="apidocSignatureSpan">execa.</span>index
        <span class="apidocSignatureSpan">(cmd, args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cmd, args, opts) =&gt; {
	let joinedCmd = cmd;

	if (Array.isArray(args) &amp;&amp; args.length &gt; 0) {
		joinedCmd += ' ' + args.join(' ');
	}

	const parsed = handleArgs(cmd, args, opts);
	const encoding = parsed.opts.encoding;
	const maxBuffer = parsed.opts.maxBuffer;

	let spawned;
	try {
		spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
	} catch (err) {
		return Promise.reject(err);
	}

	let removeExitHandler;
	if (parsed.opts.cleanup) {
		removeExitHandler = onExit(() =&gt; {
			spawned.kill();
		});
	}

	let timeoutId = null;
	let timedOut = false;

	const cleanupTimeout = () =&gt; {
		if (timeoutId) {
			clearTimeout(timeoutId);
			timeoutId = null;
		}
	};

	if (parsed.opts.timeout &gt; 0) {
		timeoutId = setTimeout(() =&gt; {
			timeoutId = null;
			timedOut = true;
			spawned.kill(parsed.killSignal);
		}, parsed.opts.timeout);
	}

	const processDone = new Promise(resolve =&gt; {
		spawned.on('exit', (code, signal) =&gt; {
			cleanupTimeout();
			resolve({code, signal});
		});

		spawned.on('error', err =&gt; {
			cleanupTimeout();
			resolve({err});
		});

		if (spawned.stdin) {
			spawned.stdin.on('error', err =&gt; {
				cleanupTimeout();
				resolve({err});
			});
		}
	});

	function destroy() {
		if (spawned.stdout) {
			spawned.stdout.destroy();
		}

		if (spawned.stderr) {
			spawned.stderr.destroy();
		}
	}

	const promise = pFinally(Promise.all([
		processDone,
		getStream(spawned, 'stdout', encoding, maxBuffer),
		getStream(spawned, 'stderr', encoding, maxBuffer)
	]).then(arr =&gt; {
		const result = arr[0];
		const stdout = arr[1];
		const stderr = arr[2];

		let err = result.err;
		const code = result.code;
		const signal = result.signal;

		if (removeExitHandler) {
			removeExitHandler();
		}

		if (err || code !== 0 || signal !== null) {
			if (!err) {
				const output = parsed.opts.stdio === 'inherit' ? '' : `\n${stderr}${stdout}`;
				err = new Error(`Command failed: ${joinedCmd}${output}`);
				err.code = code &lt; 0 ? errname(code) : code;
			}

			// TODO: missing some timeout logic for killed
			// https://github.com/nodejs/node/blob/master/lib/child_process.js#L203
			// err.killed = spawned.killed || killed;
			err.killed = err.killed || spawned.killed;

			err.stdout = stdout;
			err.stderr = stderr;
			err.failed = true;
			err.signal = signal || null;
			err.cmd = joinedCmd;
			err.timedOut = timedOut;

			if (!parsed.opts.reject) {
				return err;
			}

			throw err;
		}

		return {
			stdout: handleOutput(parsed.opts, stdout),
			stderr: handleOutput(parsed.opts, stderr),
			code: 0,
			failed: false,
			killed: false,
			signal: null,
			cmd: joinedCmd,
			timedOut: false
		};
	}), destroy);

	crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);

	handleInput(spawned, parsed.opts);

	spawned.then = promise.then.bind(promise);
	spawned.catch = promise.catch.bind(promise);

	return spawned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.index.shell" id="apidoc.element.execa.index.shell">
        function <span class="apidocSignatureSpan">execa.index.</span>shell
        <span class="apidocSignatureSpan">(cmd, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cmd, opts) =&gt; handleShell(module.exports, cmd, opts)</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	console.log(result.stdout);
	//=&gt; 'unicorns'
});

// pipe the child process stdout to the current stdout
execa('echo', ['unicorns']).stdout.pipe(process.stdout);

execa.<span class="apidocCodeKeywordSpan">shell</span>('echo unicorns').then(result =&gt; {
	console.log(result.stdout);
	//=&gt; 'unicorns'
});

// example of catching an error
execa.shell('exit 3').catch(error =&gt; {
	console.log(error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.index.shellSync" id="apidoc.element.execa.index.shellSync">
        function <span class="apidocSignatureSpan">execa.index.</span>shellSync
        <span class="apidocSignatureSpan">(cmd, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cmd, opts) =&gt; handleShell(module.exports.sync, cmd, opts)</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Same options as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
), except the default encoding is `utf8` instead of `buffer`.

Returns the same result object as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
).

This method throws an `Error` if the command fails.

### execa.<span class="apidocCodeKeywordSpan">shellSync</span>(file, [options])

Execute a command synchronously through the system shell.

Same options as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
), except the default encoding is `utf8` instead of `buffer`.

Returns the same result object as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.index.spawn" id="apidoc.element.execa.index.spawn">
        function <span class="apidocSignatureSpan">execa.index.</span>spawn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated() {
  warned = exports.printDeprecationMessage(msg, warned, deprecated);
  if (new.target) {
    return Reflect.construct(fn, arguments, new.target);
  }
  return fn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	const parsed = handleArgs(cmd, args, opts);
	const encoding = parsed.opts.encoding;
	const maxBuffer = parsed.opts.maxBuffer;

	let spawned;
	try {
		spawned = childProcess.<span class="apidocCodeKeywordSpan">spawn</span>(parsed.cmd, parsed.args, parsed.opts);
	} catch (err) {
		return Promise.reject(err);
	}

	let removeExitHandler;
	if (parsed.opts.cleanup) {
		removeExitHandler = onExit(() =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.index.stderr" id="apidoc.element.execa.index.stderr">
        function <span class="apidocSignatureSpan">execa.index.</span>stderr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stderr = function () {
	// TODO: set `stdout: 'ignore'` when that option is implemented
	return module.exports.apply(null, arguments).then(x =&gt; x.stderr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Returns a [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess), which is enhanced
 to also be a `Promise` for a result `Object` with `stdout` and `stderr` properties.

### execa.stdout(file, [arguments], [options])

Same as `execa()`, but returns only `stdout`.

### execa.<span class="apidocCodeKeywordSpan">stderr</span>(file, [arguments], [options])

Same as `execa()`, but returns only `stderr`.

### execa.shell(command, [options])

Execute a command through the system shell. Prefer `execa()` whenever possible, as it's both faster and safer.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.index.stdout" id="apidoc.element.execa.index.stdout">
        function <span class="apidocSignatureSpan">execa.index.</span>stdout
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stdout = function () {
	// TODO: set `stderr: 'ignore'` when that option is implemented
	return module.exports.apply(null, arguments).then(x =&gt; x.stdout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Same options as [`child_process.spawn`](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options
).

Think of this as a mix of `child_process.execFile` and `child_process.spawn`.

Returns a [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess), which is enhanced
 to also be a `Promise` for a result `Object` with `stdout` and `stderr` properties.

### execa.<span class="apidocCodeKeywordSpan">stdout</span>(file, [arguments], [options])

Same as `execa()`, but returns only `stdout`.

### execa.stderr(file, [arguments], [options])

Same as `execa()`, but returns only `stderr`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.execa.index.sync" id="apidoc.element.execa.index.sync">
        function <span class="apidocSignatureSpan">execa.index.</span>sync
        <span class="apidocSignatureSpan">(cmd, args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(cmd, args, opts) =&gt; {
	const parsed = handleArgs(cmd, args, opts);

	if (isStream(parsed.opts.input)) {
		throw new TypeError('The `input` option cannot be a stream in sync mode');
	}

	const result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);

	if (result.error || result.status !== 0) {
		throw (result.error || new Error(result.stderr === '' ? result.stdout : result.stderr));
	}

	result.stdout = handleOutput(parsed.opts, result.stdout);
	result.stderr = handleOutput(parsed.opts, result.stderr);

	return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Same options as [`child_process.spawn`](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options
).

Returns a [`child_process` instance](https://nodejs.org/api/child_process.html#child_process_class_childprocess).

The `child_process` instance is enhanced to also be promise for a result object with `stdout` and `stderr` properties.

### execa.<span class="apidocCodeKeywordSpan">sync</span>(file, [arguments], [options])

Execute a file synchronously.

Same options as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
), except the default encoding is `utf8` instead of `buffer`.

Returns the same result object as [`child_process.spawnSync`](https://nodejs.org/api/child_process.html#child_process_child_process_spawnsync_command_args_options
).
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>